import dotenv from 'dotenv';
import express, { Request, Response } from 'express';
import fs from 'fs';
import http from 'http';
import path from 'path';
import { Server as SocketIOServer } from 'socket.io';
import { generateAcronym } from './utils/acronyms';

dotenv.config();


import { Worker } from 'worker_threads';

import {
	// BotOptions, // Now exported from botWorker
	WorkerMessage,
	MessageType,
	ChatRequestData,
	JsonRequestData,
	LlmResponsePayload,
	
} from './src/botWorker'; // Adjusted import assuming BotOptions is exported now
import { SerializedState } from './src/server/serverUtils';
import { LogEntry } from './types/log.types'; // Corrected import path
import { BotOptions } from './src/createAgentBot'; // Import BotOptions from createAgentBot

import {
	callLLMJsonSchema,
	getLLMMetrics,
	setLLMLogger,
	toggleLLMEnabled,
	NamedJSONSchema, // Import NamedJSONSchema
} from './utils/llmWrapper';

import OpenAI from 'openai';

const LOGFILE_PATH_PREFIX = path.join(__dirname, '../');


const app = express();
// eslint-disable-next-line @typescript-eslint/no-misused-promises
const server = http.createServer(app);
const io = new SocketIOServer(server);

if (process.env.MC_HOST == undefined) {
	throw new Error('MC_HOST not loaded');
}

if (process.env.MC_PORT == undefined) {
	throw new Error('MC_PORT not loaded');
}


const workers = new Map<string, Worker>();

const botStates = new Map<string, SerializedState>();
const botLogs = new Map<string, LogEntry[]>();


const botOptionsList: BotOptions[] = [
	{
		host: process.env.MC_HOST,
		port: parseInt(process.env.MC_PORT, 10),
		username: 'AgentBot',
		version: process.env.MINECRAFT_VERSION,
	},
	{
		host: process.env.MC_HOST,
		port: parseInt(process.env.MC_PORT, 10),
		username: 'DaBiggestBird',
		version: process.env.MINECRAFT_VERSION,
	},
];
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });


setLLMLogger((type, message, meta) => {
	console.log(`[LLMLog-${type}] ${message}`, meta ? JSON.stringify(meta) : '');
	// Could also emit this via socket.io if needed
});

// --- Worker Initialization ---
function initializeWorkers() {
	console.log('Initializing workers...');

	const acronymMap = new Map<string, string>(); // To detect duplicates
	const validatedBotOptions: BotOptions[] = []; // Store options with acronyms after validation

	// --- Step 1: Generate Acronyms and Validate ---
	console.log('[Main] Generating and validating bot acronyms...');
	for (const options of botOptionsList) {
		if (!options.username) {
			console.error('Bot username is missing in options:', options);
			// Skip this bot configuration if username is missing
			continue;
		}
		const workerUsername = options.username;
		let acronym: string;

		try {
			acronym = generateAcronym(workerUsername); // Generate acronym using the helper
			if (!acronym) {
				 console.warn(`[Main] No capital letters found in username '${workerUsername}'. Acronym will be empty.`);
				 // Depending on requirements, you might want to throw an error here instead:
				 // throw new Error(`Could not generate acronym for '${workerUsername}' (no capital letters).`);
			}
		} catch (error: unknown) { // Use unknown for catch block error
			// Handle unexpected errors from generateAcronym
			console.error(
				`[Main] Failed to generate acronym for '${workerUsername}':`,
				// Check if error is an instance of Error
				error instanceof Error ? error.message : String(error)
			);
			// Stop server initialization if acronym generation fails critically
			throw new Error(
				`Acronym generation failed for bot '${workerUsername}'. Server startup aborted.`
			);
		}

		// --- Conflict Check: Reserved "all" ---
		if (acronym.toLowerCase() === 'all') {
			throw new Error(
				 `[Main] Acronym conflict! Bot '${workerUsername}' generates the reserved acronym 'all'. Please change the username.`
			);
		}


		if (acronym && acronymMap.has(acronym)) {
			const existingBot = acronymMap.get(acronym);

			throw new Error(
				`[Main] Duplicate acronym detected! Acronym '${acronym}' is generated by both '${existingBot}' and '${workerUsername}'. Please ensure bot usernames produce unique acronyms based on capital letters.`
			);
		}


		if (acronym) {
			 acronymMap.set(acronym, workerUsername);
		}
		console.log(
			`[Main] Acronym '${acronym || '(empty)'}' validated for bot '${workerUsername}'.`
		);
		validatedBotOptions.push({ ...options, acronym });
	}
	console.log('[Main] Acronym validation complete.');


	console.log('[Main] Creating worker threads...');
	validatedBotOptions.forEach((optionsWithAcronym) => {
		const workerUsername = optionsWithAcronym.username;
		 if (!workerUsername) return;

		console.log(`Creating worker for ${workerUsername} with acronym '${optionsWithAcronym.acronym || '(empty)'}'...`);
		const worker = new Worker(path.resolve(__dirname, 'src/botWorker.js'), {
			workerData: optionsWithAcronym,
		});

		workers.set(workerUsername, worker);

		botStates.set(workerUsername, {} as SerializedState);
		botLogs.set(workerUsername, []);

		// --- Worker Message Handling ---
		worker.on('message', (message: WorkerMessage) => {
			const msgUsername = ('payload' in message && message.payload && typeof message.payload === 'object' && 'username' in message.payload)
									? message.payload.username
									: undefined;


			switch (message.type) {
				case MessageType.Initialized:
					if (msgUsername) {
						 console.log(
							 `[Main] Worker ${msgUsername} initialized successfully.`
						 );
						 // Request initial state after initialization
						 worker.postMessage({ type: MessageType.GetState });
					 } else {
						 console.warn('[Main] Received \'initialized\' message without username.');
					 }
					break;
				case MessageType.StateUpdate:
					// Ensure payload and state exist before accessing
					if (msgUsername && 'payload' in message && message.payload && message.payload.state) {
						 botStates.set(msgUsername, message.payload.state);

						 // Update logs if conversationLog is present in the state
						 if (message.payload.state.conversationLog) {
							 botLogs.set(
								 msgUsername,
								 message.payload.state.conversationLog
							 );
						 }
					 } else {
						 console.warn('[Main] Received \'stateUpdate\' message without username or state payload.');
					 }
					break;
				case MessageType.LogEntry:
					// Ensure payload and entry exist
					if (msgUsername && 'payload' in message && message.payload && message.payload.entry) {
						 const entry = message.payload.entry;
						 const currentLogs = botLogs.get(msgUsername) || [];
						 currentLogs.push(entry);
						 botLogs.set(msgUsername, currentLogs);

						 // Append to file log
						 try {
							 const logFilePath = `${LOGFILE_PATH_PREFIX}${msgUsername}_conversation.log`;
							 fs.appendFileSync(
								 logFilePath,
								 JSON.stringify(entry) + '\n',
								 'utf8'
							 );
						 } catch (e: unknown) { // Catch unknown error
							 console.error(`[Main] Error writing log for ${msgUsername}:`, e instanceof Error ? e.message : String(e)); // Safe error logging
						 }
					 } else {
						 console.warn('[Main] Received \'logEntry\' message without username or entry payload.');
					 }
					break;
				case MessageType.LlmRequest:
					// Ensure requestId and payload exist
					if (message.requestId && 'payload' in message && message.payload) {
						console.log(
							`[Main] Handling LLM Request ${message.requestId} from ${msgUsername || 'unknown worker'}`
						);
						// Pass the specific payload type expected by handleProxiedLLMRequest
						void handleProxiedLLMRequest(worker, message.requestId, message.payload as ProxiedLlmPayload);
					} else {
						 console.warn('[Main] Received \'llmRequest\' message without requestId or payload.');
					}
					break;
				case MessageType.GoalPlanProgress:
				case MessageType.GoalPlanComplete:
				case MessageType.GoalPlanError:
					 { // Block scope for type narrowing
						 console.log(
							 `[Main] Forwarding goal plan update type ${message.type} from ${msgUsername || 'unknown'}`
						 );
						 let dataToSend: unknown = undefined;
						 if ('payload' in message && message.payload) {
							 // Narrow types for safe access
							 if (message.type === MessageType.GoalPlanProgress && 'tree' in message.payload) {
								 dataToSend = (message.payload).tree;
							 } else if (message.type === MessageType.GoalPlanComplete && 'tree' in message.payload) {
								 dataToSend = (message.payload).tree;
							 } else if (message.type === MessageType.GoalPlanError && 'error' in message.payload) {
								 dataToSend = (message.payload).error;
							 } else {
								  console.warn(`[Main] Received '${message.type}' message with unexpected payload structure.`);
							 }
						 } else {
							 console.warn(`[Main] Received '${message.type}' message without payload.`);
						 }

						 // Emit the determined data
						 io.emit(message.type, {
							 username: msgUsername,
							 data: dataToSend,
						 });
					 }
					break;
				case MessageType.BotError:
				case MessageType.BotKicked:
				case MessageType.BotEnd:
				case MessageType.InitializationError:
					// Ensure payload exists for logging details
					const errorDetails = ('payload' in message && message.payload) ? message.payload : 'No details available';
					console.error(
						`[Main] Critical event from worker ${msgUsername || 'unknown'}: ${message.type}`,
						errorDetails
					);
					// Optionally add logic here to restart the worker or notify admin
					break;
				default:
					// Use type assertion if necessary, or handle unknown types gracefully
					// const unknownMessageType: never = message; // This would error if not all types handled
					console.warn(
						`[Main] Received unknown message type from ${workerUsername}: ${(message as WorkerMessage).type}`
					);
			}
		});


		worker.on('error', (err) => {
			console.error(`[Main] Worker ${workerUsername} error:`, err);
			workers.delete(workerUsername);
			botStates.delete(workerUsername);
			botLogs.delete(workerUsername);
		});

		worker.on('exit', (code) => {
			console.log(`[Main] Worker ${workerUsername} exited with code ${code}`);
			workers.delete(workerUsername);
			botStates.delete(workerUsername);
			botLogs.delete(workerUsername);
			if (code !== 0) {
				console.error(`[Main] Worker ${workerUsername} exited abnormally!`);
				// Consider adding restart logic here
			}
		});
	});
	console.log('[Main] Worker creation loop finished.');
}



type ProxiedLlmPayload =
	| { type: 'chat'; data: ChatRequestData }
	| { type: 'json'; data: JsonRequestData };

// Function to handle LLM requests proxied from workers
// Function to handle LLM requests proxied from workers
async function handleProxiedLLMRequest(
  worker: Worker,
  requestId: string,
  // Use the specific union type for payload
  payload: ProxiedLlmPayload
) {
  // Destructure payload safely based on its type
  const { type, data } = payload;

  let responsePayload: LlmResponsePayload;
  try {
    // Log the type of request being handled
    console.log(`[Main LLM Proxy] Request ${requestId} - Type: ${type}`);

    // Handle 'chat' type requests
    if (type === 'chat') {
      // Ensure data matches ChatRequestData structure implicitly
      const completion = await openai.chat.completions.create({
        model: data.model || 'gpt-4o',
        messages: data.messages,
        tools: data.tools,
        tool_choice: data.tool_choice,
        parallel_tool_calls: data.parallel_tool_calls,
      });
      responsePayload = { response: completion };
      console.log(`[Main LLM Proxy] Response ${requestId} - Success (Chat)`);
    }
    // Handle 'json' type requests
    else if (type === 'json') {
      // Ensure data matches JsonRequestData structure implicitly
      const result = await callLLMJsonSchema(
        data.systemMsg,
        data.userMsg,
        // Assert that the unknown schema is compatible with NamedJSONSchema
        data.jsonSchema as NamedJSONSchema
      );
      responsePayload = { response: result.parsed };
      console.log(`[Main LLM Proxy] Response ${requestId} - Success (JSON)`);
    }
    // Handle unsupported types
    else {
      // This case should be unreachable if ProxiedLlmPayload is defined correctly
      // const exhaustiveCheck: never = type; // Use for exhaustiveness checking
      // FIX: Cast 'type' (which is 'never' here) to 'string' for the error message.
      throw new Error(`Unsupported LLM proxy type: ${type as string}`);
    }
  // Catch any errors during API calls or processing
  } catch (error: unknown) {
    console.error(
      `[Main LLM Proxy] Error processing request ${requestId}:`,
      error
    );
    // Create an error response payload, safely converting error to string
    responsePayload = { error: error instanceof Error ? error.message : String(error) };
  }

  // Send the response (or error) back to the worker
  worker.postMessage({
    type: MessageType.LlmResponse,
    requestId,
    payload: responsePayload,
  });
}

// --- Express Setup ---
app.use(express.static(path.join(__dirname, '../public')));

// Serve the main HTML file for the root and goal-planner routes
app.get('/', (req: Request, res: Response) => {
	res.sendFile(path.join(__dirname, '../public/index.html'));
});

app.get('/goal-planner', (req: Request, res: Response) => {
	res.sendFile(path.join(__dirname, '../public/index.html'));
});

// Endpoint to toggle LLM requests globally
app.post('/toggle-llm', (req: Request, res: Response) => {
	const newState = toggleLLMEnabled();
	const message = newState ? 'LLM requests enabled.' : 'LLM requests disabled.';
	res.json({ message: message, enabled: newState });
});

// --- Socket.IO Setup ---
io.on('connection', (socket) => {
	console.log('Browser connected via Socket.IO:', socket.id);

	// Send initial state snapshot to newly connected client
	if (botStates.size > 0) {
		// Construct a comprehensive initial state including logs
		const allCurrentStates: Record<string, SerializedState & { conversationLog: LogEntry[] }> = {};
		botStates.forEach((state, username) => {
			// Combine state with logs
			allCurrentStates[username] = {
				...state, // Spread the existing state properties
				conversationLog: botLogs.get(username) || [], // Add logs or empty array
			};
		});
		socket.emit('allSharedStates', allCurrentStates);
	}

	// Periodically send updated state to all connected clients
	const intervalId = setInterval(() => {
		try {
			// Create a structure to hold the state for all bots
			const allCurrentStates: Record<string, Partial<SerializedState> & { conversationLog: LogEntry[], llmMetrics: ReturnType<typeof getLLMMetrics>}> = {};

			// Iterate through active workers/bots
			workers.forEach((_, username) => {
				// Get current state and logs for the bot
				const state = botStates.get(username);
				const logs = botLogs.get(username) || [];

				// Initialize the entry for this bot if it doesn't exist
				if (!allCurrentStates[username]) {
					allCurrentStates[username] = { conversationLog: [], llmMetrics: getLLMMetrics() }; // Initialize with logs and metrics
				}

				// Merge the current state if it exists
				if (state) {
					Object.assign(allCurrentStates[username], state);
				}

				// Ensure logs and metrics are up-to-date
				allCurrentStates[username].conversationLog = logs;
				allCurrentStates[username].llmMetrics = getLLMMetrics(); // Get latest metrics
			});
			// Emit the combined state to all clients
			socket.emit('allSharedStates', allCurrentStates);
		} catch (error: unknown) { // Catch unknown errors
			console.error('[Main] Error in server state update interval:', error instanceof Error ? error.message : String(error)); // Safe error logging
		}
	}, 1000); // Update interval (1 second)

	// Clean up interval on client disconnect
	socket.on('disconnect', () => {
		clearInterval(intervalId);
		console.log('Browser disconnected:', socket.id);
	});

	// Listener for starting a goal plan from the client
	socket.on(
		'startGoalPlan',
		 // Define expected data structure
		 (data: { goal: string; mode?: 'bfs' | 'dfs', username?: string }) => { // Added username
			try {
				const goal = data.goal;
				const mode = data.mode || 'bfs'; // Default to 'bfs'
				const targetUsername = data.username || 'AgentBot'; // Default to AgentBot if not specified

				// Find the worker for the target bot
				const targetWorker = workers.get(targetUsername);
				if (!targetWorker) {
					throw new Error(`Target bot worker (${targetUsername}) not found.`);
				}
				console.log(
					`[Main] Relaying startGoalPlan to ${targetUsername} worker for goal: "${goal}"`
				);

				// Send message to the specific worker
				targetWorker.postMessage({
					type: MessageType.StartGoalPlan,
					payload: { goal, mode }, // Send goal and mode
				});
			// Handle errors during the process
			} catch (err: unknown) {
				console.error('[Main] Error starting goal plan:', err);
				// Emit an error back to the client who requested the plan
				socket.emit(
					'goalPlanError',
					// Safely convert error to string
					err instanceof Error ? err.message : 'Unknown error starting goal plan'
				);
			}
		}
	);
});

// --- Server Start ---
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
	console.log(`Server running on http://localhost:${PORT}`);
	console.log(`Dashboard: http://localhost:${PORT} \n`);
	const runStartDateAndTime = new Date(Date.now());
	console.log('Run Started at:', runStartDateAndTime.toLocaleString(), '\n');

	// Initialize workers after server starts listening
	initializeWorkers();
});

// --- Graceful Shutdown ---
process.on('SIGINT', () => void (async () => { // Add void operator for the async IIFE
	console.log('SIGINT received. Shutting down workers...');
	const exitPromises: Promise<void>[] = [];

	workers.forEach((worker, username) => {
		console.log(`[Main] Terminating worker ${username}...`);
		const exitPromise = new Promise<void>((resolve, reject) => {
			// Listen for exit event
			worker.once('exit', (code) => {
				console.log(`[Main] Worker ${username} exited with code ${code}`);
				if (code !== 0) {
					console.warn(`[Main] Worker ${username} exited abnormally.`);
					// Optionally add logic here if abnormal exit needs special handling
				}
				resolve(); // Resolve promise on exit
			});
			// Listen for error during termination
			worker.once('error', (err) => {
				console.error(`[Main] Error during termination for ${username}:`, err);
				reject(err); // Reject promise on error
			});

			// Initiate termination
			void worker.terminate(); // Terminate doesn't return a promise, handle via events
		});
		exitPromises.push(exitPromise);
	});

	// Timeout for shutdown process
	const shutdownTimeout = setTimeout(() => {
		console.error('Shutdown timed out. Forcing exit.');
		process.exit(1); // Force exit if workers don't terminate in time
	}, 10000); // 10 second timeout

	try {
		// Wait for all worker exit promises to complete
		await Promise.all(exitPromises);
		console.log('[Main] All workers have exited.');
		clearTimeout(shutdownTimeout); // Clear the timeout if shutdown is successful
		process.exit(0); // Exit gracefully
	} catch (error: unknown) { // Catch unknown errors during shutdown
		console.error('[Main] Error during worker termination:', error instanceof Error ? error.message : String(error)); // Safe error logging
		clearTimeout(shutdownTimeout); // Clear timeout on error
		process.exit(1); // Exit with error code
	}
})()); // Immediately invoke the async function