This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  observer.ts
.gitignore
index.ts
input.txt
package.json
pseudo.txt
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: src/observer.ts
================
// src/observer.ts

import { Bot } from 'mineflayer'
import type { Entity } from 'prismarine-entity'
import type { Block } from 'prismarine-block'
import Vec3 from 'vec3'

type Vec3Type = ReturnType<typeof Vec3>

export interface ObserverOptions {
  radius?: number
}

export class Observer {
  private bot: Bot
  private radius: number

  constructor(bot: Bot, options: ObserverOptions = {}) {
    this.bot = bot
    this.radius = options.radius ?? 16
  }

  /**
   * Returns an object describing each unique block type (other than air)
   * within `this.radius` of the bot, along with coordinates of the closest
   * block of that type.
   *
   * Example return:
   * {
   *   BlockTypes: {
   *     dirt: { x: 12, y: 64, z: 7 },
   *     sand: { x: 14, y: 65, z: 9 }
   *   }
   * }
   */
  public async getVisibleBlockTypes(): Promise<{
    BlockTypes: {
      [blockName: string]: { x: number; y: number; z: number }
    }
  }> {
    await this.bot.waitForChunksToLoad()

    // 1. Find all positions within the given radius that match any non-air block.
    //    We'll allow up to a large count (9999) so we get as many blocks as possible.
    const positions = this.bot.findBlocks({
      point: this.bot.entity.position,
      maxDistance: this.radius,
      matching: (block: Block | null) => {
        // We only match blocks that exist and are not air
        return block !== null && block.name !== 'air'
      },
      count: 9999
    })

    // 2. Map each position to { blockName, distance, pos } and group them by blockName.
    //    We'll keep only the single closest block for each blockName.
    interface BlockInfo {
      blockName: string
      distance: number
      pos: Vec3Type
    }

    const blockInfos: BlockInfo[] = []
    const botPos = this.bot.entity.position

    for (const pos of positions) {
      const block = this.bot.blockAt(pos) as Block | null
      if (!block) continue

      const distance = botPos.distanceTo(pos)
      blockInfos.push({
        blockName: block.name,
        distance,
        pos
      })
    }

    // 3. Group by blockName, pick the closest block for each group.
    const closestByType: {
      [key: string]: { distance: number; pos: Vec3Type }
    } = {}

    for (const info of blockInfos) {
      const existing = closestByType[info.blockName]
      if (!existing || info.distance < existing.distance) {
        closestByType[info.blockName] = { distance: info.distance, pos: info.pos }
      }
    }

    // 4. Build the final return structure
    const result: {
      BlockTypes: {
        [blockName: string]: { x: number; y: number; z: number }
      }
    } = { BlockTypes: {} }

    for (const blockName of Object.keys(closestByType)) {
      const { pos } = closestByType[blockName]
      result.BlockTypes[blockName] = { x: pos.x, y: pos.y, z: pos.z }
    }

    return result
  }

  /**
   * Returns an object containing a list of mobs within `this.radius`,
   * each with its name and distance from the bot. Not grouped by type.
   *
   * Example return:
   * {
   *   Mobs: [
   *     { name: 'Skeleton', distance: 10.2 },
   *     { name: 'Creeper', distance: 12.7 },
   *     { name: 'Zombie', distance: 14.1 }
   *   ]
   * }
   */
  public async getVisibleMobs(): Promise<{
    Mobs: { name: string; distance: number }[]
  }> {
    await this.bot.waitForChunksToLoad()
    const center = this.bot.entity.position
    const result = { Mobs: [] as { name: string; distance: number }[] }

    for (const id in this.bot.entities) {
      const entity = this.bot.entities[id] as Entity

      // Ignore the bot itself and any players (players have a 'username' property).
      if (entity === this.bot.entity || (entity as any).username) continue

      // Check the distance from the bot.
      const dist = center.distanceTo(entity.position)
      if (dist <= this.radius) {
        // entity.name is often a lowercase string like 'cow', 'zombie', etc.
        // If entity.name is missing or capitalized, adjust as needed.
        result.Mobs.push({
          name: entity.name ?? 'unknown_mob',
          distance: parseFloat(dist.toFixed(2))
        })
      }
    }

    return result
  }
}

================
File: .gitignore
================
node_modules
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

================
File: index.ts
================
// index.ts
import mineflayer, { Bot } from 'mineflayer'
import { mineflayer as mineflayerViewer } from 'prismarine-viewer'
import { Observer } from './src/observer'
const minecraftData = require('minecraft-data')
// or for es6: import minecraftData from 'minecraft-data';

const mcData = minecraftData('1.21.4');

const bot: Bot = mineflayer.createBot({
  host: 'localhost',
  port: 37269,
  username: 'AgentBot',
  version: '1.21.4'
})

const observer = new Observer(bot, { radius: 16 })

function welcome() {
  bot.chat('hi there!')
}

bot.once('spawn', async () => {
  // Launch the prismarine viewer for visualization
  mineflayerViewer(bot, { port: 3000, firstPerson: false })
  welcome()
  await bot.waitForChunksToLoad()
 //console.log(mcData.blocks)
  // Create the observer instance before registering the chat event.


})

bot.on('error', (err: Error) => {
  bot.chat(`${err.name} ${err.message}`)
  console.log('\n ERROR ERROR ERROR \n', err, '\n ERROR ERROR ERROR \n')
})

// Listen for any chat message.
bot.on('chat', async (username: string, message: string) => {
  // Ignore our own messages.
  if (username === bot.username) return

  // Get visible blocks and mobs.
  const visibleBlocks = observer.getVisibleBlockTypes()
  const visibleMobs = await observer.getVisibleMobs()

  // Format block information.
  // We assume each block has a "name" property.
  const blocksStr = visibleBlocks
    .map((block: any) => (block ? block.name : 'unknown'))
    .join(', ')

  // Format mob information.
  // If a mob has a "username" property, use it; otherwise, use a default label.
  const mobsStr = visibleMobs
    .map((mob: any) => (mob.name ? mob.name : 'mob'))
    .join(', ')

  // Chat the visible blocks and mobs. Bots can only chat strings.
  bot.chat(`Visible Blocks: ${blocksStr}`)
  bot.chat(`Visible Mobs: ${mobsStr}`)
})

================
File: input.txt
================
PIANO Architecture: A Brain-Inspired Approach to Humanlike AI

We introduce PIANO (Parallel Input Aggregation via Neural Orchestration), an architecture inspired by the brain. It leverages two key design principles—concurrency and an information bottleneck—to enable AI agents to interact with their environment in real time, much like a pianist orchestrates multiple notes into a single, coherent performance.

1. Concurrency

The Problem:
Agents must be capable of thinking and acting concurrently. Slow processes (e.g., self-reflection or planning) should not block immediate responses to environmental changes.

Current Limitations:
	•	Single-Threaded Design: Most LLM-based agents use sequential workflows, assuming that tasks occur one at a time and on similar timescales.
	•	Framework Constraints: Popular frameworks (e.g., DSPy, LangChain) are not optimized for concurrent programming.

Our Solution:
	•	Concurrent Modules: Inspired by the brain’s ability to process different functions simultaneously, our architecture runs various modules (e.g., cognition, planning, motor execution, and speech) concurrently.
	•	Stateless Functions & Shared State: Each module operates as a stateless function, reading from and writing to a shared Agent State.
	•	Context-Specific Execution: Modules can be selectively activated (e.g., social modules during interactions) and operate at speeds appropriate to their function (e.g., fast reflexes vs. deliberate planning).

2. Coherence

The Problem:
Running multiple modules in parallel can lead to incoherent outputs (e.g., the agent might say one thing while doing another).

Current Limitations:
	•	Sequential Systems: Coherence is easier to maintain when outputs are generated sequentially.
	•	Multiple Output Modalities: With various independent modules (e.g., arms, legs, facial expressions, speech), maintaining a unified behavior becomes challenging.

Our Solution:
	•	Cognitive Controller (CC): A dedicated module that makes high-level decisions, ensuring that outputs from various modules align.
	•	Information Bottleneck: The CC receives a filtered subset of the Agent State, focusing on relevant information and allowing for explicit control over data flow.
	•	Broadcast Mechanism: Once a high-level decision is made, it is broadcast to all relevant modules, ensuring that actions (especially those related to speech) are coherent with the overall decision-making process.
	•	Neuroscientific Inspiration: This design mirrors theories of human consciousness where a centralized decision-maker coordinates various outputs.

Core Modules

Our system consists of 10 concurrent modules. Key modules include:
	•	Memory: Stores and retrieves interactions, actions, and observations across various timescales.
	•	Action Awareness: Monitors the agent’s state and performance for real-time adjustments.
	•	Goal Generation: Develops new objectives based on the agent’s experiences and environmental feedback.
	•	Social Awareness: Interprets and responds to social cues to support cooperation and communication.
	•	Talking: Manages both speech interpretation and generation.
	•	Skill Execution: Performs specific actions within the environment.

By integrating these modules into a concurrent and bottlenecked architecture, our agents achieve continuous, coherent behavior, balancing fast responses with deliberate planning.

================
File: package.json
================
{
  "name": "agent_simulator",
  "version": "1.0.0",
  "description": "repo for working on minecraft agents",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "start": "npm run build && node dist/index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "canvas": "^3.1.0",
    "mineflayer": "^4.26.0",
    "mineflayer-collectblock": "^1.6.0",
    "mineflayer-pathfinder": "^2.4.5",
    "prismarine-viewer": "^1.33.0",
    "repomix": "^0.2.28"
  },
  "devDependencies": {
    "@types/node": "^22.13.4",
    "typescript": "^5.7.3"
  }
}

================
File: pseudo.txt
================
// --- Initialization ---
initialize SharedAgentState    // Central shared state (readable/writable by all modules)
initialize Environment         // External world simulation

// Initialize concurrent modules as stateless functions
initialize MemoryModule                // Stores/retrieves long/short-term memories
initialize ActionAwarenessModule       // Monitors current performance and adjusts actions
initialize GoalGenerationModule        // Generates new objectives based on experience
initialize SocialAwarenessModule       // Interprets/responds to social cues
initialize TalkingModule               // Interprets and generates speech outputs
initialize SkillExecutionModule        // Prepares and executes physical/environmental actions

// Initialize the Cognitive Controller (CC)
// Acts as a centralized bottleneck to ensure coherent, high-level decision-making.
initialize CognitiveController        


// --- Main Execution Loop ---
while simulation_is_running:
    
    // 1. Perception: Update shared agent state from environment
    sensory_input = Environment.getSensoryData()
    SharedAgentState.update(sensory_input)
    
    // 2. Concurrent Module Processing:
    // Each module operates concurrently and accesses the shared agent state.
    parallel:
        memory_out         = MemoryModule.process(SharedAgentState)
        action_awareness   = ActionAwarenessModule.process(SharedAgentState)
        goal_plan          = GoalGenerationModule.process(SharedAgentState)
        social_analysis    = SocialAwarenessModule.process(SharedAgentState)
        speech_interpret   = TalkingModule.process(SharedAgentState)
        skill_preparation  = SkillExecutionModule.prepare(SharedAgentState)
    end parallel
    
    // 3. Information Aggregation via the Bottleneck:
    // The Cognitive Controller (CC) receives a filtered version of the shared state,
    // along with outputs from the various modules.
    filtered_state  = SharedAgentState.filterForDecision()  // Explicit control over data flow
    aggregated_info = aggregate(
                          memory_out,
                          action_awareness,
                          goal_plan,
                          social_analysis,
                          speech_interpret,
                          skill_preparation,
                          filtered_state
                      )
    
    // 4. High-Level Decision-Making:
    // The Cognitive Controller produces a coherent high-level decision
    // ensuring that outputs across modalities are aligned.
    high_level_decision = CognitiveController.decide(aggregated_info)
    
    // 5. Broadcast Decision to Output Modules:
    // The decision is sent to both the Talking and Skill Execution modules,
    // guaranteeing that speech and action are coherent.
    speech_output = TalkingModule.generate(high_level_decision)
    action_command = SkillExecutionModule.execute(high_level_decision)
    
    // 6. Execute Outputs in the Environment:
    Environment.execute({
        "action": action_command,
        "speech": speech_output
    })
    
    // 7. Logging & State Update:
    // Log the decision and outcomes for learning, debugging, or future planning.
    SharedAgentState.log({
        "decision": high_level_decision,
        "action": action_command,
        "speech": speech_output,
        "sensory": sensory_input
    })
    
    // 8. Maintain Real-Time Responsiveness:
    // Wait for the next cycle while preserving concurrency (allowing fast reflexes and slow planning)
    wait(delta_time)

================
File: README.md
================
Jibbum's Agent Sim

================
File: tsconfig.json
================
{
    "compilerOptions": {
      "target": "ES2020",
      "module": "CommonJS",
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "outDir": "dist",
      "rootDir": "."
    },
    "include": ["src/**/*", "index.ts"],
    "exclude": ["node_modules", "dist"]
  }



================================================================
End of Codebase
================================================================
